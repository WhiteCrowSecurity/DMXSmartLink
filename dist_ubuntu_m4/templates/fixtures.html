{% extends "base.html" %}

{% block title %}DMX Fixtures - DMXSmartLink Hub{% endblock %}

{% block extra_styles %}
<style>
    .channel-mapping-item {
      display: block;
      padding: 0;
      background-color: transparent;
      border: none;
      margin-bottom: 16px;
    }
    .channel-mapping-item input,
    .channel-mapping-item select {
      margin: 0;
      background-color: #2d2d2d !important;
      color: #ffffff !important;
      border: 1px solid #3b3b3b !important;
      padding: 8px 12px !important;
      border-radius: 6px !important;
      font-size: 0.9rem !important;
    }
    .channel-mapping-item select {
      flex: 1;
      appearance: auto !important;
      -webkit-appearance: menulist !important;
      -moz-appearance: menulist !important;
      min-width: 120px;
    }
    .channel-mapping-item input[type="number"] {
      width: 80px;
      flex: 0 0 80px;
    }
    .channel-mapping-item .remove-btn {
      padding: 8px 16px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
    }
    .channel-mapping-item .remove-btn:hover {
      background: #dc2626;
    }
    .add-channel-btn {
      padding: 10px 20px;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      margin-top: 12px;
    }
    .add-channel-btn:hover {
      background: #059669;
    }
    .channel-mapping-list {
      margin-top: 16px;
    }
    .channel-capabilities-list {
      margin-top: 8px;
      margin-left: 20px;
      border-left: 2px solid #3b3b3b;
      padding-left: 16px;
    }
    .capability-item {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 8px;
      background-color: #1a1a1a;
      border-radius: 6px;
      margin-bottom: 6px;
      border: 1px solid #3b3b3b;
    }
    .capability-item input,
    .capability-item select {
      margin: 0;
      background-color: #2d2d2d !important;
      color: #ffffff !important;
      border: 1px solid #3b3b3b !important;
      padding: 6px 10px !important;
      border-radius: 4px !important;
      font-size: 0.85rem !important;
    }
    .capability-item input[type="number"] {
      width: 70px;
      flex: 0 0 70px;
    }
    .capability-item input[type="text"] {
      flex: 1;
      min-width: 150px;
    }
    .capability-item select {
      flex: 1;
      min-width: 120px;
    }
    .capability-item .cap-name-select {
      flex: 1;
      min-width: 180px;
    }
    .capability-item .remove-capability-btn {
      padding: 6px 12px;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }
    .add-capability-btn {
      padding: 6px 12px;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      margin-top: 8px;
    }
    .channel-item-header {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 12px;
      background-color: #252525;
      border-radius: 8px;
      margin-bottom: 8px;
      border: 1px solid #3b3b3b;
    }
    .channel-item-header input[type="number"] {
      width: 100px;
      flex: 0 0 100px;
    }
    .mode-toggle-btn {
      padding: 6px 12px;
      background: #6366f1;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      margin-left: auto;
    }
    .mode-toggle-btn:hover {
      background: #4f46e5;
    }
    .mode-toggle-btn.simple {
      background: #10b981;
    }
    .channel-simple-content {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 12px;
      background-color: #1a1a1a;
      border-radius: 6px;
      margin-bottom: 8px;
    }
    .fixture-info-text {
      color: #a0a0a0;
      font-size: 0.9rem;
      margin-bottom: 16px;
    }
  </style>
{% endblock %}

{% block content %}
<div class="container">
    <a href="{{ url_for('index') }}" class="back-link">‚Üê Back to Dashboard</a>
    <h1>DMX Fixtures (Universe {{ dmx_usb_universe }})</h1>
    
    <div class="card">
      <div class="action-buttons" style="margin-bottom: 20px;">
        <a href="{{ url_for('groups_visual_control') }}" class="btn btn-control" style="font-size: 1rem; padding: 14px 24px;">üé® Visual Control</a>
        <a href="{{ url_for('fixtures_library_view') }}" class="btn btn-secondary" style="font-size: 1rem; padding: 14px 24px;">üìö Fixture Library</a>
      </div>
      <p class="fixture-info-text">
        <strong>Note:</strong> DMX fixtures represent physical DMX devices connected via XLR cable or Art-Net. 
        Universe {{ dmx_usb_universe }} is reserved for fixtures. Fixtures can route via USB to XLR output port or via Art-Net over network. 
        Each fixture requires channel mapping to define what each DMX channel controls (RGB, brightness, color temp, pan, tilt, etc.).
        <br><strong>Tip:</strong> Use "Advanced Mode" for channels with multiple DMX ranges (e.g., shutter/strobe channels).
      </p>
      
      <h2 style="margin-top: 0;">Create New Fixture</h2>
      <form id="createFixtureForm">
        <div class="form-group">
          <label for="manufacturer">Manufacturer:</label>
          <input type="text" id="manufacturer" placeholder="e.g., Generic, Custom" required>
        </div>
        
        <div class="form-group">
          <label for="fixture_name">Fixture Name:</label>
          <input type="text" id="fixture_name" placeholder="Fixture Name" required>
        </div>
        
        <div class="form-group">
          <label for="description">Description (Optional):</label>
          <input type="text" id="description" placeholder="Brief description of the fixture">
        </div>
        
        <div class="form-group">
          <label>Channel Mapping:</label>
          <p style="color: #a0a0a0; font-size: 0.85rem; margin-bottom: 12px;">
            Define what each DMX channel does. Use "Advanced Mode" for channels with multiple DMX ranges (e.g., different functions at different DMX values).
          </p>
          <div id="channelMappingList" class="channel-mapping-list">
            <!-- Channel mappings will be added here dynamically -->
          </div>
          <button type="button" class="add-channel-btn" onclick="addChannelMapping()">+ Add Channel</button>
        </div>
        <button type="button" onclick="createFixture()" class="btn">Create Fixture</button>
      </form>
    </div>

  {% for fixture_name, fixture_info in fixtures.items() %}
      <div class="group-card">
        <div class="group-header">
          <h2 style="margin: 0;">Fixture: {{ fixture_name }}</h2>
        </div>
        <div class="group-info">
          <strong>Universe:</strong> {{ dmx_usb_universe }} | <strong>Channels:</strong> {{ fixture_info.channel_mapping|length }} channel(s)
        </div>
        
        <div class="card" style="margin-top: 20px; background-color: #1a1a1a;">
          <h3 style="margin-top: 0; margin-bottom: 16px;">Channel Mapping</h3>
          <div id="channelMapping_{{ fixture_name }}" class="channel-mapping-list" data-fixture="{{ fixture_name }}">
            {% for ch_map in fixture_info.channel_mapping %}
              <div class="channel-mapping-item" data-channel="{{ ch_map.channel }}">
                <label style="min-width: 80px; color: #a0a0a0;">Channel:</label>
                <input type="number" value="{{ ch_map.channel }}" min="1" max="512" style="width: 80px;" disabled class="ch-input-channel">
                <label style="min-width: 100px; color: #a0a0a0;">Type:</label>
                <select disabled style="flex: 1;" class="ch-select-type">
                  {% for ch_type in supported_channel_types %}
                    <option value="{{ ch_type }}" {% if ch_map.type == ch_type %}selected{% endif %}>{{ ch_type }}</option>
                  {% endfor %}
                </select>
                <label style="min-width: 60px; color: #a0a0a0;">Min:</label>
                <input type="number" value="{{ ch_map.get('min', 0) }}" min="0" max="255" style="width: 80px;" disabled class="ch-input-min">
                <label style="min-width: 60px; color: #a0a0a0;">Max:</label>
                <input type="number" value="{{ ch_map.get('max', 255) }}" min="0" max="255" style="width: 80px;" disabled class="ch-input-max">
                <button type="button" class="remove-btn" style="display: none;" onclick="removeChannelMappingItem(this)">Remove</button>
              </div>
            {% endfor %}
          </div>
          <div id="channelMappingActions_{{ fixture_name }}" style="margin-top: 12px;">
            <button type="button" onclick="editChannelMapping('{{ fixture_name }}')" class="btn" id="editBtn_{{ fixture_name }}">Edit Channel Mapping</button>
            <div id="editActions_{{ fixture_name }}" style="display: none; margin-top: 12px;">
              <button type="button" onclick="addChannelToMapping('{{ fixture_name }}')" class="add-channel-btn">+ Add Channel</button>
              <button type="button" onclick="saveChannelMapping('{{ fixture_name }}')" class="btn" style="margin-left: 8px;">Save Changes</button>
              <button type="button" onclick="cancelEditChannelMapping('{{ fixture_name }}')" class="btn btn-secondary" style="margin-left: 8px;">Cancel</button>
            </div>
          </div>
        </div>
        
        <div class="action-buttons" style="margin-top: 16px;">
          <a href="{{ url_for('delete_fixture_link', fixture_name=fixture_name) }}" class="btn btn-danger" onclick="return confirm('Are you sure you want to delete fixture {{ fixture_name }}?');">Delete Fixture</a>
        </div>
      </div>
  {% endfor %}
  
    {% if fixtures|length == 0 %}
      <div class="card">
        <p style="color: #a0a0a0; text-align: center; padding: 40px 20px;">
          No fixtures yet. Create your first fixture above to get started.
        </p>
      </div>
    {% endif %}
  </div>
{% endblock %}

{% block extra_scripts %}
<script>
    const SUPPORTED_CHANNEL_TYPES = {{ supported_channel_types|tojson|safe }};
    let channelMappingCounter = 0;

    function addChannelMapping(channel = null, mode = 'simple', type = 'red', min = 0, max = 255) {
      const list = document.getElementById('channelMappingList');
      const item = document.createElement('div');
      item.className = 'channel-mapping-item';
      item.dataset.index = channelMappingCounter++;
      item.dataset.mode = mode;
      
      // Header with channel number and mode toggle
      const header = document.createElement('div');
      header.className = 'channel-item-header';
      
      const channelLabel = document.createElement('label');
      channelLabel.textContent = 'Channel:';
      channelLabel.style.minWidth = '80px';
      channelLabel.style.color = '#a0a0a0';
      
      const channelInput = document.createElement('input');
      channelInput.type = 'number';
      channelInput.className = 'channel-number-input';
      channelInput.min = '1';
      channelInput.max = '512';
      channelInput.required = true;
      channelInput.value = channel || '';
      
      const modeToggle = document.createElement('button');
      modeToggle.type = 'button';
      modeToggle.className = 'mode-toggle-btn ' + mode;
      modeToggle.textContent = mode === 'simple' ? 'Switch to Advanced Mode' : 'Switch to Simple Mode';
      modeToggle.onclick = function() { toggleChannelMode(item); };
      
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'remove-btn';
      removeBtn.textContent = 'Remove';
      removeBtn.onclick = function() { item.remove(); };
      
      header.appendChild(channelLabel);
      header.appendChild(channelInput);
      header.appendChild(modeToggle);
      header.appendChild(removeBtn);
      item.appendChild(header);
      
      // Simple mode content
      const simpleContent = document.createElement('div');
      simpleContent.className = 'channel-simple-content';
      if (mode !== 'simple') simpleContent.style.display = 'none';
      
      const simpleTypeLabel = document.createElement('label');
      simpleTypeLabel.textContent = 'Type:';
      simpleTypeLabel.style.minWidth = '100px';
      simpleTypeLabel.style.color = '#a0a0a0';
      
      const typeSelect = document.createElement('select');
      SUPPORTED_CHANNEL_TYPES.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        if (t === type) opt.selected = true;
        typeSelect.appendChild(opt);
      });
      
      const minLabel = document.createElement('label');
      minLabel.textContent = 'Min:';
      minLabel.style.minWidth = '60px';
      minLabel.style.color = '#a0a0a0';
      
      const minInput = document.createElement('input');
      minInput.type = 'number';
      minInput.min = '0';
      minInput.max = '255';
      minInput.value = min;
      
      const maxLabel = document.createElement('label');
      maxLabel.textContent = 'Max:';
      maxLabel.style.minWidth = '60px';
      maxLabel.style.color = '#a0a0a0';
      
      const maxInput = document.createElement('input');
      maxInput.type = 'number';
      maxInput.min = '0';
      maxInput.max = '255';
      maxInput.value = max;
      
      simpleContent.appendChild(simpleTypeLabel);
      simpleContent.appendChild(typeSelect);
      simpleContent.appendChild(minLabel);
      simpleContent.appendChild(minInput);
      simpleContent.appendChild(maxLabel);
      simpleContent.appendChild(maxInput);
      item.appendChild(simpleContent);
      
      // Advanced mode content (capabilities list)
      const advancedContent = document.createElement('div');
      advancedContent.className = 'channel-capabilities-list';
      if (mode === 'simple') advancedContent.style.display = 'none';
      
      const addCapabilityBtn = document.createElement('button');
      addCapabilityBtn.type = 'button';
      addCapabilityBtn.className = 'add-capability-btn';
      addCapabilityBtn.textContent = '+ Add Capability';
      addCapabilityBtn.onclick = function() { addCapability(advancedContent); };
      advancedContent.appendChild(addCapabilityBtn);
      
      item.appendChild(advancedContent);
      
      // If advanced mode, add one default capability
      if (mode === 'advanced') {
        addCapability(advancedContent, type, min, max);
      }
      
      list.appendChild(item);
    }
    
    function toggleChannelMode(item) {
      const currentMode = item.dataset.mode;
      const newMode = currentMode === 'simple' ? 'advanced' : 'simple';
      item.dataset.mode = newMode;
      
      const simpleContent = item.querySelector('.channel-simple-content');
      const advancedContent = item.querySelector('.channel-capabilities-list');
      const modeToggle = item.querySelector('.mode-toggle-btn');
      
      if (newMode === 'simple') {
        simpleContent.style.display = 'flex';
        advancedContent.style.display = 'none';
        modeToggle.textContent = 'Switch to Advanced Mode';
        modeToggle.className = 'mode-toggle-btn simple';
        advancedContent.innerHTML = '<button type="button" class="add-capability-btn" onclick="addCapability(this.parentElement)">+ Add Capability</button>';
      } else {
        simpleContent.style.display = 'none';
        advancedContent.style.display = 'block';
        modeToggle.textContent = 'Switch to Simple Mode';
        modeToggle.className = 'mode-toggle-btn';
        // Ensure the "Add Capability" button exists
        if (!advancedContent.querySelector('.add-capability-btn')) {
          const addCapabilityBtn = document.createElement('button');
          addCapabilityBtn.type = 'button';
          addCapabilityBtn.className = 'add-capability-btn';
          addCapabilityBtn.textContent = '+ Add Capability';
          addCapabilityBtn.onclick = function() { addCapability(advancedContent); };
          advancedContent.appendChild(addCapabilityBtn);
        }
        if (advancedContent.querySelectorAll('.capability-item').length === 0) {
          const typeSelect = simpleContent.querySelector('select');
          const inputs = simpleContent.querySelectorAll('input[type="number"]');
          const type = typeSelect ? typeSelect.value : 'red';
          const min = inputs.length > 0 ? parseInt(inputs[0].value) || 0 : 0;
          const max = inputs.length > 1 ? parseInt(inputs[1].value) || 255 : 255;
          addCapability(advancedContent, type, min, max);
        }
      }
    }
    
    function addCapability(container, type = 'red', rangeMin = 0, rangeMax = 255, name = '') {
      const capItem = document.createElement('div');
      capItem.className = 'capability-item';
      
      const rangeMinLabel = document.createElement('label');
      rangeMinLabel.textContent = 'Range Min:';
      rangeMinLabel.style.minWidth = '90px';
      rangeMinLabel.style.color = '#a0a0a0';
      
      const rangeMinInput = document.createElement('input');
      rangeMinInput.type = 'number';
      rangeMinInput.className = 'cap-range-min';
      rangeMinInput.min = '0';
      rangeMinInput.max = '255';
      rangeMinInput.value = rangeMin;
      
      const rangeMaxLabel = document.createElement('label');
      rangeMaxLabel.textContent = 'Range Max:';
      rangeMaxLabel.style.minWidth = '90px';
      rangeMaxLabel.style.color = '#a0a0a0';
      
      const rangeMaxInput = document.createElement('input');
      rangeMaxInput.type = 'number';
      rangeMaxInput.className = 'cap-range-max';
      rangeMaxInput.min = '0';
      rangeMaxInput.max = '255';
      rangeMaxInput.value = rangeMax;
      
      const typeLabel = document.createElement('label');
      typeLabel.textContent = 'Type:';
      typeLabel.style.minWidth = '80px';
      typeLabel.style.color = '#a0a0a0';
      
      const typeSelect = document.createElement('select');
      typeSelect.className = 'cap-type';
      SUPPORTED_CHANNEL_TYPES.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        if (t === type) opt.selected = true;
        typeSelect.appendChild(opt);
      });
      
      const nameLabel = document.createElement('label');
      nameLabel.textContent = 'Name (optional):';
      nameLabel.style.minWidth = '120px';
      nameLabel.style.color = '#a0a0a0';
      
      // For strobe/shutter types, use dropdown; for others, use text input
      const typeValue = type || 'red';
      let nameField;
      
      if (typeValue === 'strobe' || typeValue === 'shutter') {
        // Dropdown for strobe/shutter options
        nameField = document.createElement('select');
        nameField.className = 'cap-name-select';
        
        // Strobe/shutter options based on Lightkey
        const strobeShutterOptions = {
          'shutter': [
            {value: '', text: '-- Select --'},
            {value: 'Shutter Open', text: 'Shutter Open'},
            {value: 'Shutter Closed', text: 'Shutter Closed'}
          ],
          'strobe': [
            {value: '', text: '-- Select --'},
            {value: 'Strobe', text: '‚ö° Strobe'},
            {value: 'Random Strobe', text: '‚ö° Random Strobe'},
            {value: 'Synchronized Strobe', text: '‚ö° Synchronized Strobe'},
            {value: 'Random Synchronized Strobe', text: '‚ö° Random Synchronized Strobe'},
            {value: 'Lightning Strobe', text: '‚ö° Lightning Strobe'},
            {value: 'Sound-Active Strobe', text: '‚ö° Sound-Active Strobe'},
            {value: 'Pulse Opening', text: '‚ñ≤ Pulse Opening'},
            {value: 'Random Pulse Opening', text: '‚ñ≤ Random Pulse Opening'},
            {value: 'Pulse Closing', text: '‚ñº Pulse Closing'},
            {value: 'Random Pulse Closing', text: '‚ñº Random Pulse Closing'},
            {value: 'Pulse Alternating', text: '‚ñ≤‚ñº Pulse Alternating'},
            {value: 'Random Pulse Alternating', text: '‚ñ≤‚ñº Random Pulse Alternating'},
            {value: 'Burst Pulse', text: '‚ñ≤‚ñ≤‚ñ≤ Burst Pulse'},
            {value: 'Random Burst Pulse', text: '‚ñ≤‚ñ≤‚ñ≤ Random Burst Pulse'}
          ]
        };
        
        const options = strobeShutterOptions[typeValue] || strobeShutterOptions['strobe'];
        options.forEach(opt => {
          const optionEl = document.createElement('option');
          optionEl.value = opt.value;
          optionEl.textContent = opt.text;
          if (opt.value === name) optionEl.selected = true;
          nameField.appendChild(optionEl);
        });
        
        // Update dropdown when type changes
        typeSelect.onchange = function() {
          const newType = this.value;
          const parent = nameField.parentElement;
          const removeBtn = parent.querySelector('.remove-capability-btn');
          
          if (newType === 'strobe' || newType === 'shutter') {
            // Replace with dropdown
            nameField.remove();
            const newDropdown = document.createElement('select');
            newDropdown.className = 'cap-name-select';
            const strobeShutterOptions2 = {
              'shutter': [
                {value: '', text: '-- Select --'},
                {value: 'Shutter Open', text: 'Shutter Open'},
                {value: 'Shutter Closed', text: 'Shutter Closed'}
              ],
              'strobe': [
                {value: '', text: '-- Select --'},
                {value: 'Strobe', text: '‚ö° Strobe'},
                {value: 'Random Strobe', text: '‚ö° Random Strobe'},
                {value: 'Synchronized Strobe', text: '‚ö° Synchronized Strobe'},
                {value: 'Random Synchronized Strobe', text: '‚ö° Random Synchronized Strobe'},
                {value: 'Lightning Strobe', text: '‚ö° Lightning Strobe'},
                {value: 'Sound-Active Strobe', text: '‚ö° Sound-Active Strobe'},
                {value: 'Pulse Opening', text: '‚ñ≤ Pulse Opening'},
                {value: 'Random Pulse Opening', text: '‚ñ≤ Random Pulse Opening'},
                {value: 'Pulse Closing', text: '‚ñº Pulse Closing'},
                {value: 'Random Pulse Closing', text: '‚ñº Random Pulse Closing'},
                {value: 'Pulse Alternating', text: '‚ñ≤‚ñº Pulse Alternating'},
                {value: 'Random Pulse Alternating', text: '‚ñ≤‚ñº Random Pulse Alternating'},
                {value: 'Burst Pulse', text: '‚ñ≤‚ñ≤‚ñ≤ Burst Pulse'},
                {value: 'Random Burst Pulse', text: '‚ñ≤‚ñ≤‚ñ≤ Random Burst Pulse'}
              ]
            };
            const opts = strobeShutterOptions2[newType] || strobeShutterOptions2['strobe'];
            opts.forEach(opt => {
              const optionEl = document.createElement('option');
              optionEl.value = opt.value;
              optionEl.textContent = opt.text;
              newDropdown.appendChild(optionEl);
            });
            nameField = newDropdown;
          } else {
            // Replace with text input
            nameField.remove();
            const newInput = document.createElement('input');
            newInput.type = 'text';
            newInput.className = 'cap-name';
            newInput.placeholder = newType === 'built_in_program' ? 'e.g., Manual Control, Program 1' : 'e.g., Program 1, Manual Control';
            newInput.value = '';
            nameField = newInput;
          }
          
          parent.insertBefore(nameField, removeBtn);
        };
      } else {
        // Text input for other types (including built_in_program)
        nameField = document.createElement('input');
        nameField.type = 'text';
        nameField.className = 'cap-name';
        if (typeValue === 'built_in_program') {
          nameField.placeholder = 'e.g., Manual Control, Program 1';
        } else {
          nameField.placeholder = 'e.g., Program 1, Manual Control';
        }
        nameField.value = name;
        
        // Update name field type when type changes
        typeSelect.onchange = function() {
          const newType = this.value;
          const parent = nameField.parentElement;
          const removeBtn = parent.querySelector('.remove-capability-btn');
          
          if (newType === 'strobe' || newType === 'shutter') {
            // Replace with dropdown
            nameField.remove();
            const newDropdown = document.createElement('select');
            newDropdown.className = 'cap-name-select';
            const strobeShutterOptions3 = {
              'shutter': [
                {value: '', text: '-- Select --'},
                {value: 'Shutter Open', text: 'Shutter Open'},
                {value: 'Shutter Closed', text: 'Shutter Closed'}
              ],
              'strobe': [
                {value: '', text: '-- Select --'},
                {value: 'Strobe', text: '‚ö° Strobe'},
                {value: 'Random Strobe', text: '‚ö° Random Strobe'},
                {value: 'Synchronized Strobe', text: '‚ö° Synchronized Strobe'},
                {value: 'Random Synchronized Strobe', text: '‚ö° Random Synchronized Strobe'},
                {value: 'Lightning Strobe', text: '‚ö° Lightning Strobe'},
                {value: 'Sound-Active Strobe', text: '‚ö° Sound-Active Strobe'},
                {value: 'Pulse Opening', text: '‚ñ≤ Pulse Opening'},
                {value: 'Random Pulse Opening', text: '‚ñ≤ Random Pulse Opening'},
                {value: 'Pulse Closing', text: '‚ñº Pulse Closing'},
                {value: 'Random Pulse Closing', text: '‚ñº Random Pulse Closing'},
                {value: 'Pulse Alternating', text: '‚ñ≤‚ñº Pulse Alternating'},
                {value: 'Random Pulse Alternating', text: '‚ñ≤‚ñº Random Pulse Alternating'},
                {value: 'Burst Pulse', text: '‚ñ≤‚ñ≤‚ñ≤ Burst Pulse'},
                {value: 'Random Burst Pulse', text: '‚ñ≤‚ñ≤‚ñ≤ Random Burst Pulse'}
              ]
            };
            const opts = strobeShutterOptions3[newType] || strobeShutterOptions3['strobe'];
            opts.forEach(opt => {
              const optionEl = document.createElement('option');
              optionEl.value = opt.value;
              optionEl.textContent = opt.text;
              newDropdown.appendChild(optionEl);
            });
            nameField = newDropdown;
          } else {
            // Keep text input, update placeholder
            if (nameField.tagName !== 'INPUT') {
              nameField.remove();
              const newInput = document.createElement('input');
              newInput.type = 'text';
              newInput.className = 'cap-name';
              newInput.placeholder = newType === 'built_in_program' ? 'e.g., Manual Control, Program 1' : 'e.g., Program 1, Manual Control';
              newInput.value = '';
              nameField = newInput;
            } else {
              nameField.placeholder = newType === 'built_in_program' ? 'e.g., Manual Control, Program 1' : 'e.g., Program 1, Manual Control';
            }
          }
          
          parent.insertBefore(nameField, removeBtn);
        };
      }
      
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'remove-capability-btn';
      removeBtn.textContent = 'Remove';
      removeBtn.onclick = function() { capItem.remove(); };
      
      capItem.appendChild(rangeMinLabel);
      capItem.appendChild(rangeMinInput);
      capItem.appendChild(rangeMaxLabel);
      capItem.appendChild(rangeMaxInput);
      capItem.appendChild(typeLabel);
      capItem.appendChild(typeSelect);
      capItem.appendChild(nameLabel);
      capItem.appendChild(nameField);
      capItem.appendChild(removeBtn);
      
      const addBtn = container.querySelector('.add-capability-btn');
      container.insertBefore(capItem, addBtn);
    }

    function createFixture() {
      const manufacturer = document.getElementById('manufacturer').value;
      const fixtureName = document.getElementById('fixture_name').value;
      const description = document.getElementById('description').value;
      
      if (!manufacturer || !fixtureName) {
        alert('Please enter manufacturer and fixture name.');
        return;
      }
      
      const channelItems = document.querySelectorAll('#channelMappingList .channel-mapping-item');
      if (channelItems.length === 0) {
        alert('Please add at least one channel mapping.');
        return;
      }
      
      const channelMapping = [];
      const channels = new Set();
      
      for (let channelItem of channelItems) {
        const channelInput = channelItem.querySelector('.channel-number-input');
        const channel = parseInt(channelInput.value);
        
        if (!channel || channel < 1 || channel > 512) {
          alert('Each channel must be between 1 and 512.');
          return;
        }
        
        if (channels.has(channel)) {
          alert('Channel ' + channel + ' is used more than once. Each channel can only be used once per fixture.');
          return;
        }
        channels.add(channel);
        
        const mode = channelItem.dataset.mode || 'simple';
        
        if (mode === 'simple') {
          const simpleContent = channelItem.querySelector('.channel-simple-content');
          const typeSelect = simpleContent.querySelector('select');
          const inputs = simpleContent.querySelectorAll('input[type="number"]');
          const min = parseInt(inputs[0].value) || 0;
          const max = parseInt(inputs[1].value) || 255;
          
          if (min > max) {
            alert('Channel ' + channel + ': Min cannot be greater than Max.');
            return;
          }
          
          channelMapping.push({
            channel: channel,
            type: typeSelect.value,
            min: min,
            max: max
          });
        } else {
          const capabilityItems = channelItem.querySelectorAll('.capability-item');
          if (capabilityItems.length === 0) {
            alert('Channel ' + channel + ': Advanced mode requires at least one capability.');
            return;
          }
          
          const capabilities = [];
          for (let capItem of capabilityItems) {
            const rangeMin = parseInt(capItem.querySelector('.cap-range-min').value);
            const rangeMax = parseInt(capItem.querySelector('.cap-range-max').value);
            const type = capItem.querySelector('.cap-type').value;
            // Handle both text input and select dropdown for name
            const nameField = capItem.querySelector('.cap-name, .cap-name-select');
            const name = nameField ? (nameField.tagName === 'SELECT' ? nameField.value : nameField.value.trim()) : '';
            
            if (isNaN(rangeMin) || isNaN(rangeMax) || rangeMin < 0 || rangeMax > 255 || rangeMin > rangeMax) {
              alert('Channel ' + channel + ': Invalid DMX range (must be 0-255, min <= max).');
              return;
            }
            
            const capability = {
              dmxRange: [rangeMin, rangeMax],
              type: type
            };
            if (name) {
              capability.name = name;
            }
            capabilities.push(capability);
          }
          
          capabilities.sort((a, b) => a.dmxRange[0] - b.dmxRange[0]);
          
          channelMapping.push({
            channel: channel,
            capabilities: capabilities
          });
        }
      }
      
      channelMapping.sort((a, b) => a.channel - b.channel);
      
      fetch('/api/fixtures/create', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          fixture_name: fixtureName,
          manufacturer: manufacturer,
          description: description,
          channel_mapping: channelMapping
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          window.location.reload();
        } else {
          alert('Error: ' + (data.error || 'Failed to create fixture'));
        }
      })
      .catch(err => {
        console.error('Error:', err);
        alert('Error creating fixture');
      });
    }

    let originalChannelMappings = {}; // Store original state for cancel
    
    function editChannelMapping(fixtureName) {
      const listContainer = document.getElementById('channelMapping_' + fixtureName);
      if (!listContainer) return;
      
      // Store original state for cancel
      const items = listContainer.querySelectorAll('.channel-mapping-item');
      originalChannelMappings[fixtureName] = [];
      items.forEach(item => {
        originalChannelMappings[fixtureName].push({
          channel: parseInt(item.querySelector('.ch-input-channel').value),
          type: item.querySelector('.ch-select-type').value,
          min: parseInt(item.querySelector('.ch-input-min').value) || 0,
          max: parseInt(item.querySelector('.ch-input-max').value) || 255
        });
      });
      
      // Enable all inputs and selects
      items.forEach(item => {
        item.querySelector('.ch-input-channel').disabled = false;
        item.querySelector('.ch-select-type').disabled = false;
        item.querySelector('.ch-input-min').disabled = false;
        item.querySelector('.ch-input-max').disabled = false;
        const removeBtn = item.querySelector('.remove-btn');
        if (removeBtn) removeBtn.style.display = 'block';
      });
      
      // Show edit actions, hide edit button
      document.getElementById('editBtn_' + fixtureName).style.display = 'none';
      document.getElementById('editActions_' + fixtureName).style.display = 'block';
    }
    
    function cancelEditChannelMapping(fixtureName) {
      const listContainer = document.getElementById('channelMapping_' + fixtureName);
      if (!listContainer) return;
      
      // Restore original state
      if (originalChannelMappings[fixtureName]) {
        const items = listContainer.querySelectorAll('.channel-mapping-item');
        items.forEach((item, index) => {
          if (index < originalChannelMappings[fixtureName].length) {
            const orig = originalChannelMappings[fixtureName][index];
            item.querySelector('.ch-input-channel').value = orig.channel;
            item.querySelector('.ch-select-type').value = orig.type;
            item.querySelector('.ch-input-min').value = orig.min;
            item.querySelector('.ch-input-max').value = orig.max;
          }
        });
      }
      
      // Disable all inputs and selects
      const items = listContainer.querySelectorAll('.channel-mapping-item');
      items.forEach(item => {
        item.querySelector('.ch-input-channel').disabled = true;
        item.querySelector('.ch-select-type').disabled = true;
        item.querySelector('.ch-input-min').disabled = true;
        item.querySelector('.ch-input-max').disabled = true;
        const removeBtn = item.querySelector('.remove-btn');
        if (removeBtn) removeBtn.style.display = 'none';
      });
      
      // Hide edit actions, show edit button
      document.getElementById('editBtn_' + fixtureName).style.display = 'inline-block';
      document.getElementById('editActions_' + fixtureName).style.display = 'none';
      
      delete originalChannelMappings[fixtureName];
    }
    
    function addChannelToMapping(fixtureName) {
      const listContainer = document.getElementById('channelMapping_' + fixtureName);
      if (!listContainer) return;
      
      // Find the highest channel number currently in use
      const items = listContainer.querySelectorAll('.channel-mapping-item');
      let maxChannel = 0;
      items.forEach(item => {
        const ch = parseInt(item.querySelector('.ch-input-channel').value) || 0;
        if (ch > maxChannel) maxChannel = ch;
      });
      const nextChannel = maxChannel + 1;
      
      // Create new item
      const item = document.createElement('div');
      item.className = 'channel-mapping-item';
      
      item.innerHTML = `
        <label style="min-width: 80px; color: #a0a0a0;">Channel:</label>
        <input type="number" value="${nextChannel}" min="1" max="512" style="width: 80px;" class="ch-input-channel">
        <label style="min-width: 100px; color: #a0a0a0;">Type:</label>
        <select style="flex: 1;" class="ch-select-type">
          ${SUPPORTED_CHANNEL_TYPES.map(t => `<option value="${t}">${t}</option>`).join('')}
        </select>
        <label style="min-width: 60px; color: #a0a0a0;">Min:</label>
        <input type="number" value="0" min="0" max="255" style="width: 80px;" class="ch-input-min">
        <label style="min-width: 60px; color: #a0a0a0;">Max:</label>
        <input type="number" value="255" min="0" max="255" style="width: 80px;" class="ch-input-max">
        <button type="button" class="remove-btn" onclick="removeChannelMappingItem(this)">Remove</button>
      `;
      
      listContainer.appendChild(item);
    }
    
    function removeChannelMappingItem(btn) {
      btn.closest('.channel-mapping-item').remove();
    }
    
    function saveChannelMapping(fixtureName) {
      const listContainer = document.getElementById('channelMapping_' + fixtureName);
      if (!listContainer) return;
      
      const items = listContainer.querySelectorAll('.channel-mapping-item');
      if (items.length === 0) {
        alert('Please add at least one channel mapping.');
        return;
      }
      
      const channelMapping = [];
      const channels = new Set();
      
      for (let item of items) {
        const channel = parseInt(item.querySelector('.ch-input-channel').value);
        const type = item.querySelector('.ch-select-type').value;
        const min = parseInt(item.querySelector('.ch-input-min').value) || 0;
        const max = parseInt(item.querySelector('.ch-input-max').value) || 255;
        
        if (!channel || channel < 1 || channel > 512) {
          alert('Each channel must be between 1 and 512.');
          return;
        }
        
        if (channels.has(channel)) {
          alert('Channel ' + channel + ' is used more than once. Each channel can only be used once per fixture.');
          return;
        }
        channels.add(channel);
        
        channelMapping.push({
          channel: channel,
          type: type,
          min: min,
          max: max
        });
      }
      
      // Sort by channel number
      channelMapping.sort((a, b) => a.channel - b.channel);
      
      // Send to API
      fetch(`/api/fixtures/${encodeURIComponent(fixtureName)}/channel_mapping`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          channel_mapping: channelMapping
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          alert('Channel mapping updated successfully!');
          window.location.reload(); // Reload to show updated state
        } else {
          alert('Error: ' + (data.error || 'Failed to update channel mapping'));
        }
      })
      .catch(err => {
        console.error('Error:', err);
        alert('Error updating channel mapping');
      });
    }
    
    // Add default channel mappings on page load
    window.onload = function() {
      if (document.querySelectorAll('#channelMappingList .channel-mapping-item').length === 0) {
        addChannelMapping(1, 'simple', 'red', 0, 255);
        addChannelMapping(2, 'simple', 'green', 0, 255);
        addChannelMapping(3, 'simple', 'blue', 0, 255);
        addChannelMapping(4, 'simple', 'brightness', 0, 255);
        addChannelMapping(5, 'simple', 'color_temp', 0, 255);
      }
    };
  </script>
{% endblock %}
